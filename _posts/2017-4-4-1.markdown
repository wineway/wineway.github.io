---
layout:     post
title:      "[笔记]Scala学习笔记(4)"
author:     wineway
tags: 		Scala 隐式(implicit) 笔记 未完成
subtitle:   Scala隐式详解
category:  project1
visualworkflow: true
---
## 隐式详解

隐式是Scala的一个强大且富有争议的特性,使用隐式可以有效减少代码,向已有类型注入新的方法,创建**领域特定语言(DSL)**

隐式之所以会产生争议,是因为除了通过 `Predef` 对象自动加载的那些隐式对象外,其他在源码中出现的隐式对象均不是本地对象,隐式对象一旦进入作用域,编译器便能执行该隐式对象以生成方法参数或将指定参数转化为预期类型,不过在阅读源码时,读者无法简单的指出什么时候会应用这些隐式值和隐式方法,而这可能会给该读者造成困惑,幸运的是,随着经验累积,你将能偶意识到什么时候会触发这些隐式对象,你也可以通过阅读这些对象的API来学习这些知识

### 隐式参数

```scala
def calcTex (amount: Float)(implicit rate: Float): Float = amount * rate

object SimpleStateSalesTax {
  implicit val rate: Float = 0.05F
}

case class ComplicatedSalesTaxData(
  baseRate: Float,
  isTaxHoliday: Boolean,
  storeId: Int
)

object ComplicatedSalesTax {
  private def extraTaxRateForStore(id: Int):Float = {
    //通过id推断商铺所在地,然后计算附加税
    0.0F
  }

  implicit def rate(implicit cstd: ComplicatedSalesTaxData): Float =
    if (cstd.isTaxHoliday) 0.0F
    else cstd.baseRate + extraTaxRateForStore(cstd.storeId)
}

{
  import SimpleStateSalesTax.rate

  val amount = 100F
  println(s"${calcTex(amount)}")
}

{
  import ComplicatedSalesTax.rate
  implicit val myStore = ComplicatedSalesTaxData(0.06F,false,1010)

  val amount = 100F
  println(s"${calcTex(amount)}")
}
```
以上是一个示例.

#### 调用 implicity 方法

```scala
import math.Ordering

case class MyList[A](list: List[A]) {
    def sortBy1[B](f: A => B)(implicit ord: Ordering[B]): List[A] =
    list.sortBy(f)(ord)

  def sortBy2[B : Ordering](f: A => B): List[A] =
    list.sortBy(f)(implicitly[Ordering[B]])
}

val list = MyList(List(1,3,5,2,4))

list sortBy1 (i => -i)
list sortBy2 (i => -i)
```

类型参数 `B: Ordering` 被称为 **上下文定界(context bound)** 暗示第二个参数列表(隐式参数列表)将接受 `Ordering[B]` 实例,然后使用 `Predef.implicity` 方法获取参数, `implicit` 方法会对传给函数所有标记为隐式参数的实例进行解析.请注意 `implicity` 需要的类型签名,本段代码中为 `Ordering[B]`

### 隐式参数适用场景

#### 执行上下文

>使用隐式参数传入"执行上下文"

#### 功能控制

比如通过引用授权令牌控制某些特定API操作只能供某些用户调用

#### 限定可用实例

Scala集合API就是利用这项技术解决一些设计上的问题

##### 应用Scala API

Scala API运用一种常见的手法,将一个 **builder** 作为隐式参数传到 `map` 方法中, 该 **builder** 知道如何构造一个同种类型的新容器,这实际上与定义在 `TraversableLike` 中的 `map` 方法签名很相似, `TraversableLike` 是一个 `trait` 他被 **混入** 了那些 **可遍历(traversable)** 的容器中.

```scala
trait TraversableLike[+A, +Repr] extends ... {
  ...
  def map[B, That](f: A => B)(implicit bf: CanBuildForm[Repr,B,That]): That = {}
  ...
}
```

`CanBuildForm` 是我们所使用的 **builder** 只要存在一个隐式构造器对象,你便能够构建出一个人以你想要的新容器, 容器通过 `Repr` 持有内部元素, `B` 类型是我们想创建目标集合的类型参数,因此 `map` 操作可以输出的集合类型是由当前存在的对应的 `CanBuildForm` 构造器实例所决定的,而这些构造器在当前作用域被声明为 **隐式对象** 假如你自定义了某些容器,你希望能够复用 `TraversableLike.map` 这样的方法实现,你需要创建 `CanBuildForm` 类型,并在这些容器代码中导入他们的隐式实例.
```scala
package progscala2.implicits {
    package scaladb {
    object implicits {
      import javadb.JRow

      implicit class SRow(jrow: JRow) {
        def get[T](colName: String)(implicit toT: (JRow,String) => T): T =
          toT(jrow, colName)
      }

      implicit val jrowToInt: (JRow,String) => Int =
        (jrow: JRow, colName: String) => jrow.getInt(colName)
      implicit val jrowToDouble: (JRow,String) => Double =
        (jrow: JRow, colName: String) => jrow.getDouble(colName)
      implicit val jrowToString: (JRow,String) => String =
        (jrow: JRow, colName: String) => jrow.getText(colName)
        }

            object DB {
              import implicits._

              def main(args: Array[String]) = {
                val row = javadb.JRow("one" -> 1, "two" -> 2.2, "three" -> "THREE!")

                val oneValue1: Int      = row.get("one")
                val twoValue1: Double   = row.get("two")
                val threeValue1: String = row.get("three")
                // val fourValue1: Byte    = row.get("four")  // won't compile

                println(s"one1   -> $oneValue1")
                println(s"two1   -> $twoValue1")
                println(s"three1 -> $threeValue1")

                val oneValue2   = row.get[Int]("one")
                val twoValue2   = row.get[Double]("two")
                val threeValue2 = row.get[String]("three")
                // val fourValue2    = row.get[Byte]("four")  // won't compile

                println(s"one2   -> $oneValue2")
                println(s"two2   -> $twoValue2")
                println(s"three2 -> $threeValue2")
              }
            }
          }
        }
```
- `get[T]` 方法中引用了 `jrow` 实例,但是并没有使用 `val` 关键字声明,所以 `jrow` 不是该类的成员,但是类型的其他成员依然可以使用它.
- 第一遍操作系统通过变量类型推导出 `T` 类型,第二种方法显示的指定了 `get[T]` 中的参数值
- 第一行注释不会把 `byte` 隐式转换为 `Int` 或者 `Double` ,因为有歧义,但是即使没有歧义也不会通过编译,因为"both functions extract too many bytes!"(啥意思..)
- 第二个注释便于我们回忆: 通过传入一个隐式参数以及定义符合我们允许的类型所对应的隐式值,我们就可以对用于参数化方法的类型进行限定

#### 隐式证据

有时候,我们只需要限定允许的类型,并不需要额外的处理:也就是我们需要"证据"表明提出的类型满足我们的需求

```scala
trait traversableOnce[+A] {
  ...
  def toMap[T, U](implicit ev: <:<[A, (T, U)]): immutable.Map[T, U] = {
    ...
  }
}
```
隐式参数 `ev` 就是我们的证据,它代表了我们必须实施的约束, `<:<` 是在 `Predef` 中定义的类型,该名字取于 `<:` 方法, `<:` 同样被用于限定类型参数,注意两个类型参数组成的类型可以用中缀表示法//这玩意貌似是个比较运算符

证据的意义仅仅是为了实施某一类型的约束,我们无需定义一个隐式值来执行额外的自定义工作, `Predef` 对象还定义了一个名为 `=:=` 的**证据**类型,他可以证明证据类型的等价关系,但该类型未得到广泛的使用

#### 绕开类型擦除带来的限制

```scala
object M {
  implicit object IntMarker                                          //
  implicit object StringMarker

  def m(seq: Seq[Int])(implicit i: IntMarker.type): Unit =           //
    println(s"Seq[Int]: $seq")

  def m(seq: Seq[String])(implicit s: StringMarker.type): Unit =     //
    println(s"Seq[String]: $seq")
}

import M._                                                           //
m(List(1,2,3))
```

- 关于 `StringMarker.type` 单例对象类型 [宏江的博客](http://hongjiang.info/scala-type-system-singleton-type/) 有详解
- 关于这个我觉得貌似就是单纯的做个区分方法的作用....然后再编译时确定类型,只是猜想,书上没详解,以后搞懂在回来编辑#

不使用隐式 `Int` 和 `String` 的值是因为: 假设当前作用域某一模块也定义了隐式 `String` 参数,那么两个隐式参数便会导致系统出错,首先加入第二个模块并未定义默认的隐式值,而希望用户能定义适用于应用程序的隐式值,如果用户没有定义该隐式值,那么该模块便会使用其他模块的隐式值,这可能导致无法预期的行为,如果用户定义了隐式值,那么两个出现在相同作用域的隐式值将导致二义性,比较安全的做法是减少使用隐式参数及隐式值,改用那些专门为此目的设计的特有类型

#### 改善报错信息

我们如果试图对一个未定义对应的 `CanBuildFrom` 的目标类型调用 `map` 方法,会发生:
```scala
scala> case class ListWrapper(list: List[Int])
defined class ListWrapper

scala> List(1,2,3).map[Int,ListWrapper](_ * 2)
<console>:10: error: Cannot construct a collection of type ListWrapper
with elements of type Int based on a collection of type List[Int].
              List(1,2,3).map[Int,ListWrapper](_*2)
                                              ^
```
`map`方法中明确注解了类型 `map[Int, ListWrapper]` 使得输出是 `ListWrapper` 而不是 `List[Int]`,注意错误信息不是通常我们无法找到某一隐式参数产生的默认信息,实际上在声明 `CanBuildFrom` 指定了一个名为 `scala.annotation.implicitNotFound` 的注解,该注解指定了那些错误信息的格式字符串, `CanBuildFrom` 声明体如下
```scala
@implicitNotFound(msg =
  "Cannot construct a collection of type ${To} with elements of type ${Elem}" +
  " based on a collection of type ${From}.")
trait CanBuildFrom[-From, -Elem, +To] {...}
```
你只能对那些专门为满足隐式参数而定义的,用作隐式值的类型使用这类注解,而这些注解无法用于像 `SRow.get[T]` 那样的接受隐式参数输入的方法之上,这也解释了为什么构建隐式应该使用自定义类型,而不应该使用常见类型.

##### 虚类型
