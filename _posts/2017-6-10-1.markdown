---
layout:     post
title:      "[笔记]Akka tutorial"
author:     wineway
tags:       Akka 未完成
subtitle:   Akka 笔记
category:  project1
visualworkflow: true
---
# Akka 概述

## 模块

akka-actor – 标准Actor, 类型Actor，IO Actor等。
akka-agent – Agent，与 Scala STM 集成
akka-camel – Apache Camel 集成
akka-cluster – 集群成员管理，弹性路由器。
akka-kernel – Akka 微内核来运行简单应用服务器
akka-osgi – 在OSGi容器中使用Akka的基本组件，包含akka-actor类
akka-osgi-aries – Aries 的actor系统蓝图
akka-remote.jar – 远程Actor
akka-slf4j.jar – SLF4J日志(事件总线监听器)
akka-testkit.jar – Actor系统的测试工具包
akka-zeromq – ZeroMQ 集成

## 通过SBT使用Akka

通过SBT使用Akka最简单的入门是检出“Akka/SBT”模板工程。

通过SBT使用Akka的要点:

[SBT安装指导](https://github.com/harrah/xsbt/wiki/Setup)

build.sbt 文件:
```scala
name := "My Project"

version := "1.0"

scalaVersion := "2.10.4"

resolvers += "Typesafe Repository" at "http://repo.typesafe.com/typesafe/releases/"

libraryDependencies +=
  "com.typesafe.akka" %% "akka-actor" % "2.3.6"

```

注意：以上的libraryDependencies设置需要SBT 0.12.x或更高的版本。如果你使用更老版本的SBT，libraryDependencies需要这样设置：

```scala
libraryDependencies +=
  "com.typesafe.akka" % "akka-actor_2.10" % "2.3.6"

```

# 术语，概念

### 并发 vs. 并行

并发和并行是相关的定义，有一些微小的不同。并发 指的是两个或多个任务都有进展，即使他们没有被同时执行。例如可以这样实现：划分出时间片，几个任务交叉执行，尽管时间片的执行是线性的。并行 则是指可以真正同时执行。

### 异步 vs. 同步

一个方法调用是 同步 的，当调用者不能继续处理，除非方法返回一个值或抛出一个异常。另一方面，一个 异步 调用允许调用者在调用方法的有限步后能够继续执行，并且该方法的结束可以被额外的机制通知到（也许是一个注册的回调callback，一个Future或一个消息）。

一个同步的API也许会使用阻塞实现同步性，但也不是必须的。一个CPU极为密集的任务也会导致类似阻塞的行为。通常推荐使用非阻塞API，因为它们能确保系统继续处理。Actor本质上是异步的：一个Actor可以在发送消息后继续处理，而不需要等待消息确实被送达。

### 非阻塞 vs. 阻塞

如果一个线程的延迟会导致其它一些线程无限期的延迟，我们称之为 阻塞。一个很好的例子是资源可以被线程通过互斥锁独占。如果这个线程无限期地占有这个资源（例如不小心进入死循环），其他等待这个资源的线程就无法处理了。相反地，非阻塞 意味着没有线程可以无限期的阻塞其他线程。

相比阻塞操作，我们推荐非阻塞的操作，因为很明显这样系统不会因为阻塞操作而不再继续处理。

### 死锁 vs. 饥饿 vs. 活锁

当多个参与者互相等待别人达到某个特殊的状态才能继续处理的时候，死锁 出现了。因为如果一些参与者不达到特定状态，所有的参与者都不能执行（就像《第二十二条军规》描述的那样），所有相关子系统都停顿了。死锁和阻塞息息相关，因为阻塞使得一个参与者线程可以无限期地推迟其他线程的处理。

在死锁中，没有参与者可以处理，然而相对的 饥饿 可能发生，当有些参与者可以不断地处理，而另一些可能不行。一个典型的场景是一个幼稚的调度算法——总是选择高优先级的任务。如果高优先级的任务数量一直足够多，则低优先级的任务永远不会被完成。

活锁 和死锁类似，没有参与者可以处理。区别在于与进程进入等待其他进程处理的“冻结”状态不同，参与者不断地变换他们的状态。一个示例场景是两个参与者和两个特殊的资源。他们分别试图获取资源，并且检查是不是另一个参与者也需要这个资源。如果该资源被另一个参与者请求，则它们试图获取另一个资源。在一个很不幸的情况下，也许两个参与者会不停的在两个资源上“跳跃”，永远在谦让而不使用资源。

### 竞态条件

**当一组事件的顺序假设可能被外部不确定因素影响，我们称之为 *竞态条件***。竞态条件经常在多个线程共享一个可变状态时出现，一个线程对这个状态的操作可能被交织从而导致意外的行为。尽管这是常见的情况，但是共享状态并不一定会导致竞态条件。例如一个客户端向服务器发送无序的包（例如UDP数据包）P1，P2。由于包可能经过不同的网络路由器传送，所以服务器可能先收到P2，后收到P1。如果消息中没有包含发送顺序的相关信息的话，服务器是不可能确定包是否是按照发送顺序接收的。根据包的内容这可能会导致竞态条件。

### 无等待（Wait-freedom）

如果一个方法的调用可以保证在有限步骤内完成，则称该方法是 *无等待* 的。如果方法是 *有界无等待* 的，则方法的执行步数有一个确定的上界。

从这个定义可以得出无等待的方法永远不会阻塞，因此死锁是不可能发生的。此外，因为每个参与者都可以经过有限步后继续执行（当调用完成），所以无等待方法也不会出现饥饿的情况。

### 无锁（Lock-freedom）

*无锁* 是比 *无等待* 更弱的特性。在无锁调用的情况下，无限地经常有一些方法在有限步骤内完成。这个定义暗示着对无锁调用是不可能出现死锁的。另一方面，部分方法调用 在有限步骤内 结束，不足以保证所有调用最终完成。换句话说，无锁不足以保证不会出现饥饿。

### 无阻碍（Obstruction-freedom）

无阻碍 是这里讨论的最弱的无阻塞保证。对一个方法，当在某一个它独自执行的时间点（其他线程不在执行，例如都挂起了），之后它在有限步后能够结束，我们称之为 无阻碍。所有无锁的对象都是无阻碍的，但反之一般不成立。

乐观并发模型OCC（Optimistic concurrency control ） 的方法通常是无阻碍的。OCC的做法是，每一位参与者都试图在共享对象上执行操作，但是如果参与者检测到来自其他参与者的冲突，它回滚修改，并根据调度再次尝试。如果在某一个时间点，其中一个参与者，是唯一一个尝试修改的点，则其操作就会成功。

# Actor系统
Actor是封装状态和行为的对象，他们唯一的通讯方式是交换消息——把消息存放在接收方的邮箱里。从某种意义上来说，actor是面向对象最严格的形式。

>一个Actor系统是一个很重的结构，它会分配一到N个线程，所以对每一个逻辑应用创建一个就够了。

## 树形结构

象一个经济组织一样，actor自然形成树形结构。程序中负责某一功能的actor，可能需要把它的任务分拆成更小的、更易管理的部分。为此它启动子actor并监督它们。每个actor有且仅有一个监管者，就是创建它的那个actor。

设计这种系统的难度在于如何决定谁应该监管什么。这当然没有唯一的最佳方案，但是有一些指导原则可能会有帮助：

- 如果一个actor管理另一个actor所做的工作，如分配一个子任务，那么父actor应该监督子actor。因为父actor知道可能会出现哪些失败情况，以及如何处理它们。

- 如果一个actor携带着重要数据（即它的状态要尽可能地不被丢失），这个actor应该将任何可能出现危险的子任务分配给它所监管的子actor，并酌情处理子任务的失败。根据请求的性质，可能的话最好为每一个请求创建一个子actor，这样能简化收集回应的状态管理。这在Erlang中被称为“Error Kernel Pattern”。

- 如果actor A需要依赖actor B才能完成它的任务，A应该观测B的存活状态并对B的终止提醒消息进行响应。这与监管机制不同，因为观测方对监管机制没有影响；需要指出的是，仅仅是功能上的依赖并不足以用来决定是否在树形监管体系中添加子actor.

>配置线程池的任务最好代理给Akka来做，只要在application.conf中配置，并由ActorSystem [Java, Scala] 实例化即可。

## 什么是Actor?

一个Actor是一个容器，它包含了状态，行为，一个邮箱，子Actor和一个监管策略。所有这些封装在一个Actor引用里。最终在Actor终止时，会有这些发生。

### Actor引用

一个actor对象需要与外界隔离开才能从actor模型中获益。因此actor是以actor引用的形式展现给外界的，actor引用作为对象，可以被无限制地自由传递。内部和外部对象的这种划分使得所有想要的操作都能够透明：重启actor而不需要更新别处的引用，将实际actor对象放置到远程主机上，向另外一个应用程序发送消息。

### 状态

Actor对象通常包含一些变量来反映其所处的可能状态。这可以是一个明确的状态机（例如使用 FSM 模块)，或是一个计数器，一组监听器，待处理的请求，等等。

在幕后，Akka会在一组真实线程上运行Actor组，通常是很多actor共享一个线程，对某一个actor的调用可能会在不同的线程上得到处理。Akka保证这个实现细节不影响处理actor状态的单线程性。

由于内部状态对于actor的操作是至关重要的，所以状态不一致是致命的。因此当actor失败并被其监管者重新启动时，状态会被重新创建，就象第一次创建这个actor一样。这是为了实现系统的“自愈合”。

可选地，通过持久化收到的消息并在重启后重放它们，一个actor的状态可自动恢复到重启前的状态。

### 行为

每当一个消息被处理，它会与actor的当前行为进行匹配。行为是一个函数，它定义了在某个时间点处理当前消息所要采取的动作，例如如果客户已经授权，那么就对请求进行转发处理，否则拒绝。

### 邮箱

Actor的目的是处理消息，这些消息是从其它actor（或者从actor系统外部）发送过来的。连接发送者与接收者的纽带是actor的邮箱：每个actor有且仅有一个邮箱，所有的发来的消息都在邮箱里排队。排队按照发送操作的时间顺序来进行，这意味着由于actor分布在不同的线程中，所以从不同的actor发来的消息在运行时没有一个固定的顺序。

>Akka与其它actor模型实现的一个重要区别在于：当前的行为总是必须处理下一个从队列中取出的消息，Akka不会扫描邮箱队列来获取下一个匹配的消息。

### 子Actor

每个actor都是一个潜在的监管者：如果它创建了子actor来委托处理子任务，它会自动地监管它们。子actor列表维护在actor的上下文中，actor可以访问它。对列表的更改是通过创建 `(context.actorOf(...))` 或者停止 `(context.stop(child))` 子actor来完成，并且这些更改会立刻生效。实际的创建和停止操作是在幕后以异步方式完成的，这样它们就不会“阻塞”其监管者。

### 监管策略

每个actor只有唯一的策略，这意味着：如果一个actor的子actor们应用了不同的策略，则这些子actor应该按照相同的策略来进行分组，并放在一个中间的监管者下，又一次转向了根据任务到子任务的划分来组织actor系统的结构的设计方法。

### 当Actor终止时

当一个actor终止——即失败了且不能用重启来解决、停止它自己或者被它的监管者停止——它会释放其资源，将其邮箱中所有未处理的消息放进系统的“死信邮箱(dead letter mailbox)”，即将所有消息作为死信重定向到事件流中。而actor引用中的邮箱将会被一个系统邮箱所替代，将所有的新消息作为死信重定向到事件流中。 但是这些操作只是尽力而为，所以不能依赖它来实现“投递保证”。

## 监管与监控

