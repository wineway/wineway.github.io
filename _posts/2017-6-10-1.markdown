---
layout:     post
title:      "[笔记]Akka tutorial"
author:     wineway
tags:       Akka 未完成
subtitle:   Akka 笔记
category:  project1
visualworkflow: true
---
# Akka 概述

## 模块

akka-actor – 标准Actor, 类型Actor，IO Actor等。
akka-agent – Agent，与 Scala STM 集成
akka-camel – Apache Camel 集成
akka-cluster – 集群成员管理，弹性路由器。
akka-kernel – Akka 微内核来运行简单应用服务器
akka-osgi – 在OSGi容器中使用Akka的基本组件，包含akka-actor类
akka-osgi-aries – Aries 的actor系统蓝图
akka-remote.jar – 远程Actor
akka-slf4j.jar – SLF4J日志(事件总线监听器)
akka-testkit.jar – Actor系统的测试工具包
akka-zeromq – ZeroMQ 集成

## 通过SBT使用Akka

通过SBT使用Akka最简单的入门是检出“Akka/SBT”模板工程。

通过SBT使用Akka的要点:

SBT安装指导 https://github.com/harrah/xsbt/wiki/Setup

build.sbt 文件:
```scala
name := "My Project"

version := "1.0"

scalaVersion := "2.10.4"

resolvers += "Typesafe Repository" at "http://repo.typesafe.com/typesafe/releases/"

libraryDependencies +=
  "com.typesafe.akka" %% "akka-actor" % "2.3.6"

```

注意：以上的libraryDependencies设置需要SBT 0.12.x或更高的版本。如果你使用更老版本的SBT，libraryDependencies需要这样设置：

```scala
libraryDependencies +=
  "com.typesafe.akka" % "akka-actor_2.10" % "2.3.6"

```

# 术语，概念

### 并发 vs. 并行

并发和并行是相关的定义，有一些微小的不同。并发 指的是两个或多个任务都有进展，即使他们没有被同时执行。例如可以这样实现：划分出时间片，几个任务交叉执行，尽管时间片的执行是线性的。并行 则是指可以真正同时执行。

### 异步 vs. 同步

一个方法调用是 同步 的，当调用者不能继续处理，除非方法返回一个值或抛出一个异常。另一方面，一个 异步 调用允许调用者在调用方法的有限步后能够继续执行，并且该方法的结束可以被额外的机制通知到（也许是一个注册的回调callback，一个Future或一个消息）。

一个同步的API也许会使用阻塞实现同步性，但也不是必须的。一个CPU极为密集的任务也会导致类似阻塞的行为。通常推荐使用非阻塞API，因为它们能确保系统继续处理。Actor本质上是异步的：一个Actor可以在发送消息后继续处理，而不需要等待消息确实被送达。

### 非阻塞 vs. 阻塞

如果一个线程的延迟会导致其它一些线程无限期的延迟，我们称之为 阻塞。一个很好的例子是资源可以被线程通过互斥锁独占。如果这个线程无限期地占有这个资源（例如不小心进入死循环），其他等待这个资源的线程就无法处理了。相反地，非阻塞 意味着没有线程可以无限期的阻塞其他线程。

相比阻塞操作，我们推荐非阻塞的操作，因为很明显这样系统不会因为阻塞操作而不再继续处理。

### 死锁 vs. 饥饿 vs. 活锁

当多个参与者互相等待别人达到某个特殊的状态才能继续处理的时候，死锁 出现了。因为如果一些参与者不达到特定状态，所有的参与者都不能执行（就像《第二十二条军规》描述的那样），所有相关子系统都停顿了。死锁和阻塞息息相关，因为阻塞使得一个参与者线程可以无限期地推迟其他线程的处理。

在死锁中，没有参与者可以处理，然而相对的 饥饿 可能发生，当有些参与者可以不断地处理，而另一些可能不行。一个典型的场景是一个幼稚的调度算法——总是选择高优先级的任务。如果高优先级的任务数量一直足够多，则低优先级的任务永远不会被完成。

活锁 和死锁类似，没有参与者可以处理。区别在于与进程进入等待其他进程处理的“冻结”状态不同，参与者不断地变换他们的状态。一个示例场景是两个参与者和两个特殊的资源。他们分别试图获取资源，并且检查是不是另一个参与者也需要这个资源。如果该资源被另一个参与者请求，则它们试图获取另一个资源。在一个很不幸的情况下，也许两个参与者会不停的在两个资源上“跳跃”，永远在谦让而不使用资源。

### 竞态条件

当一组事件的顺序假设可能被外部不确定因素影响，我们称之为 竞态条件。竞态条件经常在多个线程共享一个可变状态时出现，一个线程对这个状态的操作可能被交织从而导致意外的行为。尽管这是常见的情况，但是共享状态并不一定会导致竞态条件。例如一个客户端向服务器发送无序的包（例如UDP数据包）P1，P2。由于包可能经过不同的网络路由器传送，所以服务器可能先收到P2，后收到P1。如果消息中没有包含发送顺序的相关信息的话，服务器是不可能确定包是否是按照发送顺序接收的。根据包的内容这可能会导致竞态条件。

