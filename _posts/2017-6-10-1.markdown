---
layout:     post
title:      "[笔记]Akka tutorial"
author:     wineway
tags:       Akka 未完成
subtitle:   Akka 笔记
category:  project1
visualworkflow: true
---
# Akka 概述

## 模块

akka-actor – 标准Actor, 类型Actor，IO Actor等。

akka-agent – Agent，与 Scala STM 集成

akka-camel – Apache Camel 集成

akka-cluster – 集群成员管理，弹性路由器。

akka-kernel – Akka 微内核来运行简单应用服务器

akka-osgi – 在OSGi容器中使用Akka的基本组件，包含akka-actor类

akka-osgi-aries – Aries 的actor系统蓝图

akka-remote.jar – 远程Actor

akka-slf4j.jar – SLF4J日志(事件总线监听器)

akka-testkit.jar – Actor系统的测试工具包

akka-zeromq – ZeroMQ 集成


## 通过SBT使用Akka

通过SBT使用Akka最简单的入门是检出“Akka/SBT”模板工程。

通过SBT使用Akka的要点:

[SBT安装指导](https://github.com/harrah/xsbt/wiki/Setup)

build.sbt 文件:
```scala
name := "My Project"

version := "1.0"

scalaVersion := "2.10.4"

resolvers += "Typesafe Repository" at "http://repo.typesafe.com/typesafe/releases/"

libraryDependencies +=
  "com.typesafe.akka" %% "akka-actor" % "2.3.6"

```

注意：以上的libraryDependencies设置需要SBT 0.12.x或更高的版本。如果你使用更老版本的SBT，libraryDependencies需要这样设置：

```scala
libraryDependencies +=
  "com.typesafe.akka" % "akka-actor_2.10" % "2.3.6"

```

# 术语，概念

### 并发 vs. 并行

并发和并行是相关的定义，有一些微小的不同。并发 指的是两个或多个任务都有进展，即使他们没有被同时执行。例如可以这样实现：划分出时间片，几个任务交叉执行，尽管时间片的执行是线性的。并行 则是指可以真正同时执行。

### 异步 vs. 同步

一个方法调用是 同步 的，当调用者不能继续处理，除非方法返回一个值或抛出一个异常。另一方面，一个 异步 调用允许调用者在调用方法的有限步后能够继续执行，并且该方法的结束可以被额外的机制通知到（也许是一个注册的回调callback，一个Future或一个消息）。

一个同步的API也许会使用阻塞实现同步性，但也不是必须的。一个CPU极为密集的任务也会导致类似阻塞的行为。通常推荐使用非阻塞API，因为它们能确保系统继续处理。Actor本质上是异步的：一个Actor可以在发送消息后继续处理，而不需要等待消息确实被送达。

### 非阻塞 vs. 阻塞

如果一个线程的延迟会导致其它一些线程无限期的延迟，我们称之为 阻塞。一个很好的例子是资源可以被线程通过互斥锁独占。如果这个线程无限期地占有这个资源（例如不小心进入死循环），其他等待这个资源的线程就无法处理了。相反地，非阻塞 意味着没有线程可以无限期的阻塞其他线程。

相比阻塞操作，我们推荐非阻塞的操作，因为很明显这样系统不会因为阻塞操作而不再继续处理。

### 死锁 vs. 饥饿 vs. 活锁

当多个参与者互相等待别人达到某个特殊的状态才能继续处理的时候，死锁 出现了。因为如果一些参与者不达到特定状态，所有的参与者都不能执行（就像《第二十二条军规》描述的那样），所有相关子系统都停顿了。死锁和阻塞息息相关，因为阻塞使得一个参与者线程可以无限期地推迟其他线程的处理。

在死锁中，没有参与者可以处理，然而相对的 饥饿 可能发生，当有些参与者可以不断地处理，而另一些可能不行。一个典型的场景是一个幼稚的调度算法——总是选择高优先级的任务。如果高优先级的任务数量一直足够多，则低优先级的任务永远不会被完成。

活锁 和死锁类似，没有参与者可以处理。区别在于与进程进入等待其他进程处理的“冻结”状态不同，参与者不断地变换他们的状态。一个示例场景是两个参与者和两个特殊的资源。他们分别试图获取资源，并且检查是不是另一个参与者也需要这个资源。如果该资源被另一个参与者请求，则它们试图获取另一个资源。在一个很不幸的情况下，也许两个参与者会不停的在两个资源上“跳跃”，永远在谦让而不使用资源。

### 竞态条件

**当一组事件的顺序假设可能被外部不确定因素影响，我们称之为 *竞态条件***。竞态条件经常在多个线程共享一个可变状态时出现，一个线程对这个状态的操作可能被交织从而导致意外的行为。尽管这是常见的情况，但是共享状态并不一定会导致竞态条件。例如一个客户端向服务器发送无序的包（例如UDP数据包）P1，P2。由于包可能经过不同的网络路由器传送，所以服务器可能先收到P2，后收到P1。如果消息中没有包含发送顺序的相关信息的话，服务器是不可能确定包是否是按照发送顺序接收的。根据包的内容这可能会导致竞态条件。

### 无等待（Wait-freedom）

如果一个方法的调用可以保证在有限步骤内完成，则称该方法是 *无等待* 的。如果方法是 *有界无等待* 的，则方法的执行步数有一个确定的上界。

从这个定义可以得出无等待的方法永远不会阻塞，因此死锁是不可能发生的。此外，因为每个参与者都可以经过有限步后继续执行（当调用完成），所以无等待方法也不会出现饥饿的情况。

### 无锁（Lock-freedom）

*无锁* 是比 *无等待* 更弱的特性。在无锁调用的情况下，无限地经常有一些方法在有限步骤内完成。这个定义暗示着对无锁调用是不可能出现死锁的。另一方面，部分方法调用 在有限步骤内 结束，不足以保证所有调用最终完成。换句话说，无锁不足以保证不会出现饥饿。

### 无阻碍（Obstruction-freedom）

无阻碍 是这里讨论的最弱的无阻塞保证。对一个方法，当在某一个它独自执行的时间点（其他线程不在执行，例如都挂起了），之后它在有限步后能够结束，我们称之为 无阻碍。所有无锁的对象都是无阻碍的，但反之一般不成立。

乐观并发模型OCC（Optimistic concurrency control ） 的方法通常是无阻碍的。OCC的做法是，每一位参与者都试图在共享对象上执行操作，但是如果参与者检测到来自其他参与者的冲突，它回滚修改，并根据调度再次尝试。如果在某一个时间点，其中一个参与者，是唯一一个尝试修改的点，则其操作就会成功。

# Actor系统
Actor是封装状态和行为的对象，他们唯一的通讯方式是交换消息——把消息存放在接收方的邮箱里。从某种意义上来说，actor是面向对象最严格的形式。

>一个Actor系统是一个很重的结构，它会分配一到N个线程，所以对每一个逻辑应用创建一个就够了。

## 树形结构

象一个经济组织一样，actor自然形成树形结构。程序中负责某一功能的actor，可能需要把它的任务分拆成更小的、更易管理的部分。为此它启动子actor并监督它们。每个actor有且仅有一个监管者，就是创建它的那个actor。

设计这种系统的难度在于如何决定谁应该监管什么。这当然没有唯一的最佳方案，但是有一些指导原则可能会有帮助：

- 如果一个actor管理另一个actor所做的工作，如分配一个子任务，那么父actor应该监督子actor。因为父actor知道可能会出现哪些失败情况，以及如何处理它们。

- 如果一个actor携带着重要数据（即它的状态要尽可能地不被丢失），这个actor应该将任何可能出现危险的子任务分配给它所监管的子actor，并酌情处理子任务的失败。根据请求的性质，可能的话最好为每一个请求创建一个子actor，这样能简化收集回应的状态管理。这在Erlang中被称为“Error Kernel Pattern”。

- 如果actor A需要依赖actor B才能完成它的任务，A应该观测B的存活状态并对B的终止提醒消息进行响应。这与监管机制不同，因为观测方对监管机制没有影响；需要指出的是，仅仅是功能上的依赖并不足以用来决定是否在树形监管体系中添加子actor.

>配置线程池的任务最好代理给Akka来做，只要在application.conf中配置，并由ActorSystem [Java, Scala] 实例化即可。

## 什么是Actor?

一个Actor是一个容器，它包含了状态，行为，一个邮箱，子Actor和一个监管策略。所有这些封装在一个Actor引用里。最终在Actor终止时，会有这些发生。

### Actor引用

一个actor对象需要与外界隔离开才能从actor模型中获益。因此actor是以actor引用的形式展现给外界的，actor引用作为对象，可以被无限制地自由传递。内部和外部对象的这种划分使得所有想要的操作都能够透明：重启actor而不需要更新别处的引用，将实际actor对象放置到远程主机上，向另外一个应用程序发送消息。

### 状态

Actor对象通常包含一些变量来反映其所处的可能状态。这可以是一个明确的状态机（例如使用 FSM 模块)，或是一个计数器，一组监听器，待处理的请求，等等。

在幕后，Akka会在一组真实线程上运行Actor组，通常是很多actor共享一个线程，对某一个actor的调用可能会在不同的线程上得到处理。Akka保证这个实现细节不影响处理actor状态的单线程性。

由于内部状态对于actor的操作是至关重要的，所以状态不一致是致命的。因此当actor失败并被其监管者重新启动时，状态会被重新创建，就象第一次创建这个actor一样。这是为了实现系统的“自愈合”。

可选地，通过持久化收到的消息并在重启后重放它们，一个actor的状态可自动恢复到重启前的状态。

### 行为

每当一个消息被处理，它会与actor的当前行为进行匹配。行为是一个函数，它定义了在某个时间点处理当前消息所要采取的动作，例如如果客户已经授权，那么就对请求进行转发处理，否则拒绝。

### 邮箱

Actor的目的是处理消息，这些消息是从其它actor（或者从actor系统外部）发送过来的。连接发送者与接收者的纽带是actor的邮箱：每个actor有且仅有一个邮箱，所有的发来的消息都在邮箱里排队。排队按照发送操作的时间顺序来进行，这意味着由于actor分布在不同的线程中，所以从不同的actor发来的消息在运行时没有一个固定的顺序。

>Akka与其它actor模型实现的一个重要区别在于：当前的行为总是必须处理下一个从队列中取出的消息，Akka不会扫描邮箱队列来获取下一个匹配的消息。

### 子Actor

每个actor都是一个潜在的监管者：如果它创建了子actor来委托处理子任务，它会自动地监管它们。子actor列表维护在actor的上下文中，actor可以访问它。对列表的更改是通过创建 `(context.actorOf(...))` 或者停止 `(context.stop(child))` 子actor来完成，并且这些更改会立刻生效。实际的创建和停止操作是在幕后以异步方式完成的，这样它们就不会“阻塞”其监管者。

### 监管策略

每个actor只有唯一的策略，这意味着：如果一个actor的子actor们应用了不同的策略，则这些子actor应该按照相同的策略来进行分组，并放在一个中间的监管者下，又一次转向了根据任务到子任务的划分来组织actor系统的结构的设计方法。

### 当Actor终止时

当一个actor终止——即失败了且不能用重启来解决、停止它自己或者被它的监管者停止——它会释放其资源，将其邮箱中所有未处理的消息放进系统的“死信邮箱(dead letter mailbox)”，即将所有消息作为死信重定向到事件流中。而actor引用中的邮箱将会被一个系统邮箱所替代，将所有的新消息作为死信重定向到事件流中。 但是这些操作只是尽力而为，所以不能依赖它来实现“投递保证”。

## 监管与监控


### 监管的意思

在 Actor 系统 中说过，监管描述的是actor之间的依赖关系：监管者将任务委托给下属，并相应地对下属的失败状况进行响应。当一个下属出现了失败（即抛出一个异常），它自己会将自己和自己所有的下属挂起，然后向自己的监管者发送一个提示失败的消息。基于所监管的工作的性质和失败的性质，监管者可以有4种基本选择：

1. 恢复下属，保持下属当前积累的内部状态
2. 重启下属，清除下属的内部状态
3. 永久地停止下属
4. 升级失败（沿监管树向上传递失败），由此失败自己


恢复actor会恢复其所有下属，重启一个actor也必须重启其所有下属（不过需要看下面的详述获取更多细节），类似地终止一个actor会终止其所有下属。需要强调Actor类的preRestart钩子（hook）缺省行为是在重启前终止它的所有下属，但这个钩子可以被重写；对所有子actor的递归重启操作在这个钩子之后执行。

>每个监管者都配置了一个函数，它将所有可能的失败原因（即异常）翻译成以上四种选择之一；注意，这个函数并不将失败actor的标识作为输入。我们很快会发现在有些结构中这种方式可能看起来不够灵活，例如会希望对不同的下属应用不同的策略。在这一点上我们一定要理解监管是为了组建一个递归的失败处理结构。如果你试图在某一个层次做太多事情，这个层次会变得复杂并难以理解，因此这时我们推荐的方法是增加一个监管层次。

Akka实现的是一种叫“父监管”的形式。Actor只能被其它的actor创建——顶部的actor由库来提供——每一个被创建的actor都由其父亲所监管.

>监管相关的父-子沟通，使用了特殊的系统消息及其固有的邮箱，从而和用户消息隔离开来。这意味着，监管相关的事件相对于普通的消息没有确定的顺序关系。在一般情况下，用户不能影响正常消息和失败通知的顺序。

### 顶级监管者

![顶级监管者](http://udn.yyuap.com/doc/akka-doc-cn/2.3.6/scala/book/chapter2/guardians.png)

一个actor系统在其创建过程中至少要启动三个actor，如上图所示。

#### `/user`: 守护Actor

这个名为"/user"的守护者，作为所有用户创建actor的父actor，可能是需要打交道最多的。使用`system.actorOf()`创建的actor都是其子actor。这意味着，当该守护者终止时，系统中所有的普通actor都将被关闭。同时也意味着，该守护者的监管策略决定了普通顶级actor是如何被监督的。自Akka 2.1起就可以使用这个设定`akka.actor.guardian-supervisor-strategy`，以一个`SupervisorStrategyConfigurator`的完整类名进行配置。当这个守护者上升一个失败，根守护者的响应是终止该守护者，从而关闭整个actor系统。

#### `/system`: 系统守护者

这个特殊的守护者被引入，是为了实现正确的关闭顺序，即日志（logging）要保持可用直到所有普通actor终止，即使日志本身也是用actor实现的。其实现方法是：系统守护者观察user守护者，并在收到Terminated消息初始化其自己的关闭过程。顶级的系统actor被监管的策略是，对收到的除`ActorInitializationException和ActorKilledException`之外的所有Exception无限地执行重启，这也将终止其所有子actor。所有其他Throwable被上升，然后将导致整个actor系统的关闭。

#### `/`: 根守护者

根守护者所谓“顶级”actor的祖父，它监督所有在Actor路径的顶级作用域中定义的特殊actor，使用发现任何Exception就终止子actor的`SupervisorStrategy.stoppingStrategy`策略。其他所有`Throwable`都会被上升……但是上升给谁？所有的真实actor都有一个监管者，但是根守护者没有父actor，因为它就是整个树结构的根。因此这里使用一个虚拟的`ActorRef`，在发现问题后立即停掉其子actor，并在根守护者完全终止之后（所有子actor递归停止），立即把actor系统的`isTerminated`置为true。

### 重启的含义

当actor在处理某条消息时失败时，失败的原因可以分成以下三类:

- 对收到的特定消息的系统错误（即程序错误）
- 处理消息时一些外部资源的（临时性）失败
- actor内部状态崩溃了

重启过程中所发生事件的精确次序是：

1. actor被挂起（意味着它不会处理正常消息直到被恢复），并递归挂起其所有子actor
2. 调用旧实例的 preRestart hook (缺省实现是向所有子actor发送终止请求并调用 postStop)
3. 等待所有子actor终止（使用context.stop()）直到 preRestart 最终结束；这里所有的actor操作都是非阻塞的，最后被杀掉的子actor的终止通知会影响下一步的执行
4. 再次调用原来提供的工厂生成actor的新实例
5. 调用新实例的postRestart方法（其默认实现是调用preStart方法）
6. 对步骤3中没有被杀死的所有子actor发送重启请求；重启的actor会遵循相同的过程，从步骤2开始
7. 恢复这个actor

### 生命周期监控(DeathWatch)的含义

与上面所描述的特殊父子关系相对的，每一个actor都可以监控其他任意actor。由于actor从创建到完全可用和重启都是除了监管者之外都不可见的，所以唯一可用于监视的状态变化是可用到失效的转变。监视因此被用于绑定两个actor，使监控者能对另一个actor的终止做出响应，而相应的，监督者是对失败做出响应。

生命周期监控是通过监管actor收到 `Terminated` 消息实现的，其默认行为是抛出一个 `DeathPactException` 。要开始监听 `Terminated` 消息，需要调用 `ActorContext.watch(targetActorRef)` 。要停止监听，需要调用 `ActorContext.unwatch(targetActorRef)` 。一个重要的特性是，消息将不考虑监控请求和目标终止发生的顺序，也就是说，即使在登记的时候目标已经死了，你仍然会得到消息。

如果一个监管者不能简单地重启其子actor，而必须终止它们，这时监控就特别有用，例如在actor初始化时发生错误。在这种情况下，它应该监控这些子actor并重新创建它们，或安排自己在稍后的时间重试。

另一个常见的应用情况是，一个actor需要在没有外部资源时失败，该资源也可能是它的子actor之一。如果第三方通过 `system.stop(child)`或发送 `PoisonPill` 的方式终止子actor，其监管者很可能会受到影响。

### 一对一策略 vs. 多对一策略

Akka中有两种类型的监管策略： `OneForOneStrategy` 和 `AllForOneStrategy` 。两者都配置有从异常类型监管指令间的映射（见上文），并限制了一个孩子被终止之前允许失败的次数。它们之间的区别在于，前者只将所获得的指令应用在发生故障的子actor上，而后者则是应用在所有孩子上。通常情况下，你应该使用 `OneForOneStrategy` ，这也是默认的策略。

`AllForOneStrategy` 适用的情况是，子actor之间有很紧密的依赖，以至于一个actor的失败会影响其他孩子，即他们是不可分开的。由于重启不清除邮箱，所以往往最好是失败时终止孩子并在监管者显式地重建它们（通过观察孩子们的生命周期）；否则你必须确保重启前入队的消息在重启后处理是没有问题的。

通常停止一个孩子（即对失败不再响应）不会自动终止多对一策略中其他的孩子；可以很容易地通过观察它们的生命周期来做到这点：如果 `Terminated` 的消息不能被监管者处理，它会抛出一个 `DeathPactException` ，并（这取决于其监管者）将重新启动，默认 `preRestart` 操作会终止所有的孩子。当然这也可以被显式地处理。

请注意，在多对一监管者下创建一个临时的actor会导致一个问题：临时actor的失败上升会使所有永久actor受到影响。如果这不是所期望的，安装一个中间监管者；这可以很容易地通过为工作者声明大小为1的路由器来完成.

## Actor引用, 路径与地址

![Actor引用, 路径与地址](http://udn.yyuap.com/doc/akka-doc-cn/2.3.6/scala/book/chapter2/ActorPath.png)

### 什么是Actor引用？

Actor引用是 ActorRef 的子类，其最重要的目的是支持向它所代表的actor发送消息。每个actor通过self字段来访问自己的标准（本地）引用；在给其它actor发送的消息中也缺省包含这个引用。反过来，在消息处理过程中，actor可以通过sender()方法来访问到当前消息的发送者的引用。

根据actor系统的配置，支持几种不同类型的actor引用：

- 纯本地actor引用，在配置为不使用网络功能的actor系统中使用。这些actor引用如果通过网络连接传给远程的JVM，将不能正常工作。
- 本地actor引用，在配置为使用远程功能的actor系统中使用，来代表同一个JVM的actor。为了能够在被发送到其它节点时仍然可达，这些引用包含了协议和远程地址信息。
- 本地actor引用的一个子类，用在路由器中（routers，即混入 了 Router trait的actor）。它的逻辑结构与之前的本地引用是一样的，但是向它们发送的消息会被直接重定向到它的子actor。
- 远程actor引用，代表可以通过远程通讯访问的actor，即向他们发送消息时会透明地对消息进行序列化，并发送到别的JVM。
- 有几种特殊的actor引用类型，在实际用途中比较类似本地actor引用：
  * PromiseActorRef 表示一个Promise，其目的是通过一个actor返回的响应来完成。它是由 akka.pattern.ask 创建的。
  * DeadLetterActorRef是死信服务的缺省实现，所有接收方被关闭或不存在的消息都被重新路由在此。
  * EmptyLocalActorRef是当查找一个不存在的本地actor路径时Akka返回的：它相当于DeadLetterActorRef，但是它保有其路径因此可以在网络上发送，并与其它相同路径的存活的actor引用进行比较，其中一些存活的actor引用可能在该actor消失之前被得到。
- 然后有一些内部实现，你应该永远不会用上：
  * 有一个actor引用并不表示任何actor，只是作为根actor的伪监管者存在，我们称它为“时空气泡穿梭者”。
  * 在actor创建设施启动之前运行的第一个日志服务，是一个伪actor引用，它接收日志事件并直接显示到标准输出上；它就是 Logging.StandardOutLogger。




