---
layout:     post
title:      "[笔记]Scala学习笔记(9)"
author:     wineway
tags: 		Scala  对象系统 笔记 未完成
subtitle:   Scala的对象系统
category:  project1
visualworkflow: true
---

# 继承转化


## 逆变

逆变最好的一个例子是一组 `trait FunctionN` ,Scala使用 `trait` 实现匿名函数, 例如:

```scala
List(1, 2, 3, 4) map (i => i + 3)
```

`(i => i + 3)` 实际上是一个语法糖, 编译器将其转化为 `scala.Function1` 的匿名子类,实现如下:

```scala
val f: Int => Int = new Function1[Int, Int] { //对象后面跟上参数列表的时候,就会调用默认的apply函数
  def apply(i: Int) = i + 3
}
```

再来讨论逆变 `trait Function1[-T1, -T2, +R] extends AnyRef` 的声明,所以函数在继承时都有混合变异的行为, 如下例:

```scala
class CSuper                { def msuper() = println("CSuper") }       //
class C      extends CSuper { def m()      = println("C") }
class CSub   extends C      { def msub()   = println("CSub") }

var f: C => C = (c: C)      => new C             //
    f         = (c: CSuper) => new CSub          //
    f         = (c: CSuper) => new C             //
    f         = (c: C)      => new CSub          //
    f         = (c: CSub)   => new CSuper        //  COMPILATION ERROR!
```

**契约式设计** 解释了为什么这些规则是有意义的,这是 **里式规则** 的一种表现形式,我们尝试凭直觉理解这些规则

函数变量 `f` 的类型时 `C => C` ,我们在第二次赋值 `(x: CSuper) => Csub` 符合声明,即参数逆变, 返回值协变

为了了解这个声明为何是安全的,我们需要了解 `f` 是如何调用的, 以及我们可以对 `f` 背后的真正函数作哪些假设, 当我们说 `f` 类型时 `C => C` 时,我们其实定义了一个 *契约* ,这样任何有效的 `C` 值都可以传给 `f` , `f` 永远也不会返回 `C` 类值以外的任何值

因此如果实际的函数类型为 `(x: CSuper) => Csub` ,该函数不仅可以接受任何 `C` 类值作为参数, 也可处理 `C` 的父类型的实例,或其父类型其他子类型的实例,所以犹豫只传入 `C` 的实例, 我们就永远不会超出 `f` 允许范围外的参数, 从某种意义上来说, `f` 比我们需要的更加宽容

同样,当他只返回 `Csub` 时,这也是安全的,因为调用方可以处理 `C` 的实例,所以也一定可以处理 `Csub` 的实例,在这个意义上来说, `f` 比我们需要的更加 "严格"

示例的最后一行同时打破了关于输入和输出类型的两个规则,,如果允许这个函数合法的赋值给 `f` 我们考虑下会发生什么

在这种情况下,实际的 `f` 函数只知道如何处理 `CSub` 实例,但是调用者对此一无所知, 认为任何 `C` 实例都可以传如 `f` ,所以当 `f` 运行发生意外时,就可能导致失败, 即调用者试图把 `C` 实例传入一个只接受 `CSub` 而不是 `C` 的函数,同样的, 如果实际 `f` 能够返回一个 `CSuper` 实例, 这将超出调用者预期的返回值范围?


### 可变类型的变异

可变类型只允许非变异行为,因为他像是一个私有的字段,却又存在共有的读写访问方法,即使可变字段是共有的并且没有显示定义访问方法,该字段依然会像私有字段一般运行

对于 `getter` 和 `setter` 方法中的可变字段而言,他在du'fang'fa读方法中出于协变的位置,而在写方法中出于逆变的位置

```
Variance of Mutable Types
All the parameterized types we’ve discussed so far have been immutable types. What about the variance behavior of mutable types? The short answer is that only invariance is allowed. Consider this example:

// src/main/scala/progscala2/objectsystem/variance/mutable-type-variance.scX

scala> class ContainerPlus[+A](var value: A)
<console>:34: error: covariant type A occurs in contravariant position
in type A of value value_=
       class ContainerPlus[+A](var value: A)
             ^

scala> class ContainerMinus[-A](var value: A)
<console>:34: error: contravariant type A occurs in covariant position
in type => A of method value
       class ContainerMinus[-A](var value: A)
                                    ^

The problem with a mutable field is that it behaves like a private field with public read and write accessor methods, even if the field is actually public and has no explicit accessor methods.
Recall from Fields in Classes that def value_=(newA: A): Unit+ is the signature the compiler interprets as the setter for variable value. That is, we can write an expression myinstance.value = someA and this method will be called. Note that the first error message uses this method signature and complains that we’re using covariant type A in a contravariant position.
The second error message mentions a method signature => A. That is, a function that takes no arguments and returns an A, just like the by-name parameters we first saw in Call by Name, Call by Value.
Here’s another way to write the declaration using these methods explicitly, which looks more like traditional Java code:
class ContainerPlus[+A](var a: A) {
  private var _value: A = a
  def value_=(newA: A): Unit = _value = newA
  def value: A = _value
}
Why must the A passed to value_=(newA: A) be contravariant? This doesn’t seem right, because we’re assigning a new value to _value, but if the new value can be a supertype of A, then we’ll get a type error, because _value must be of type A, right?
Actually, that’s the wrong way to think about the situation. The covariant/contravariant rules apply to how subclasses behave relative to superclasses.
Assume for a moment that our declaration is valid. For example, we could instantiate ContainerPlus[C], using our C, CSub, and CSuper from before:
val cp = new ContainerPlus(new C)   //
cp.value = new C                    //
cp.value = new CSub                 //
cp.value = new CSuper               //

Type parameter A is now C.

Valid: we’re just using the same type instance.

Valid for the usual object-oriented reasons, since CSub is a subtype of C.

Compilation error, because a CSuper instance can’t be substituted for a C instance.
It’s only when considering subtypes of ContainerPlus that trouble ensues:
val cp: ContainerPlus[C] = new ContainerPlus(new CSub)   //
cp.value = new C             //
cp.value = new CSub          //
cp.value = new CSuper        //

Would be valid, if ContainerPlus[+A] were valid.

From the declared type of c, this should be valid and this is why the argument type must be contravariant, but the actual value_= method for the instance can’t accept a C instance, because its value field is of type CSub.

OK.

OK.
The expression labeled  illustrates why the method argument needs to be contravariant. The user of c expects the instance to work with C instances. By looking at the actual implementation of value_=, we already know that we can’t actually support contravariance, but let’s ignore that for a moment and consider what happens if we change the variance annotation:
class ContainerMinus[-A](var a: A) {
  private var _value: A = a
  def value_=(newA: A): Unit = _value = newA
  def value: A = _value
  “}
  We already know from the error messages at the beginning of this section that this is considered OK for the value_= method (even though it isn’t actually OK), but now we get the second error we saw previously. The A is the return type for the value method, so A is in a covariant position.
  Why must it be covariant? This is a little more intuitive. Again, the behavior of subtypes is the key. Once again, assume for a moment that the compiler allows us to instantiate ContainerMinus instances:
  val cm: ContainerMinus[C] = new ContainerMinus(new CSuper)   //
  val c: C      = cm.value        //
  val c: CSuper = cm.value        //
  val c: CSub   = cm.value        //

  Would be valid, if ContainerMinus[-A] were valid.

  cm thinks its value method returns a C, but the actual value method for the instance returns a CSuper. Oops…

  OK.


Fails for the same reason in line .
So, if you think of a mutable field in terms of a getter and setter method, it appears in both covariant position when read and contravariant position when written. There is no such thing as a type parameter that is both contravariant and covariant, so the only option is for A to be invariant for the type of a mutable field.
```

### Scala 和 Java 中的变异

变异性为在Scala中定义于类型的声明过程,而在Java中定义于使用过程,Java程序员很容易指定错误的变异株是,从而导致不安全的代码,java的类型系统另一个问题是, `Array` 是协变的

## Scala的类型层次系统

`Any` 出于结构树根部位置, 没有父类, 但有三个子类:
-   `AnyVal` 价值类型和价值类的父类(9个具体子类,七个是数字值类型 `Byte` `Char` `Short` `Int` `Long` `Float` `Double`,两个非数字值类型 `Unit` `Boolean`)
-   `AnyRef` 所有引用类型的父类
-   universal trait ,新引入的 `trait` 类型

`Nothing` 和 `Null` 是位于类型系统底层的两个特殊类型, 其中 `Nothing` 是所有其他类型的子类, `Null` 是所有引用类型的子类

`Nothing` 两个用途,一个是解决 `Nil` 问题,一个是表示终止程序,比如 `???` 函数,由于其返回 `Nothing` 所以可以被任何函数调用

### Product, case 类和元组

你定义的 `case` 类会混入 `scala.Product` 特质, 他提供了几个关于实例字段的通用方法:

```scala
case class Person(name: String, age: Int)

val p: Product = Person("Dean", 12)

p.productElement(0) // Any = "Dean"

p.productArity // Int = 2
```

尽管以通用方法返回字段非常有用,但是由于对各个字段使用的都是 `Any` 类型使这种机制的作用受到了局限
对于不同的字段数量, 也有 `Product` 的子类型, 如 `scala.Product2` ,事实上 `TupleN` 类型就继承了对应的 `ProductN` 特质, 并提供了 `_1` 到 `_N` 方法的具体实现

# Predef 对象

只要你编译代码,Scala编译器就会自动导入顶层的Scala包,以及在java.lang包中的定义,因此许多常见的Java和Scala类型都可以不经过明显的导入或提供完整的名称就可以使用,另外,编译器还导入了 `Predef` 对象中的一些定义,它提供了一些很实用的定义

## 隐式转换

`Predef` 定义了很多隐式规则,以下是一组转换对 `AnyVal` 类型的包装

```scala
@inline implicit def byteWrapper(x: Byte)       = new runtime.RichByte(x)
@inline implicit def shortWrapper(x: Short)     = new runtime.RichShort(x)
@inline implicit def intWrapper(x: Int)         = new runtime.RichInt(x)
@inline implicit def charWrapper(c: Char)       = new runtime.RichChar(c)
@inline implicit def longWrapper(x: Long)       = new runtime.RichLong(x)
@inline implicit def floatWrapper(x: Float)     = new runtime.RichFloat(x)
@inline implicit def doubleWrapper(x: Double)   = new runtime.RichDouble(x)
@inline implicit def booleanWrapper(x: Boolean) = new runtime.RichBoolean(x)
```

`Rich*` 类型提供了额外的方法,类似于 `<=` 和 `compare` 等比较方法, `@inline` 标记鼓励编译器进行内联,即直接将 `new runtime.RichY(x)` 逻辑插入代码中

因为根据字节码要求,额外的方法迫使程序在堆中分配一个实例,所以拥有单独的 `Rich*` 类型是为了避免堆内存的分配

在 `scala.collection.mutable.WrappedArray` 中还存在用于包装 Java 可变数组的方法,为数组提供一些方法

```scala
implicit def wrapIntArray(xs: Array[Int]): WrappedArray[Int]
implicit def wrapDoubleArray(xs: Array[Double]): WrappedArray[Double]
implicit def wrapLongArray(xs: Array[Long]): WrappedArray[Long]
implicit def wrapFloatArray(xs: Array[Float]): WrappedArray[Float]
implicit def wrapCharArray(xs: Array[Char]): WrappedArray[Char]
implicit def wrapByteArray(xs: Array[Byte]): WrappedArray[Byte]
implicit def wrapShortArray(xs: Array[Short]): WrappedArray[Short]
implicit def wrapBooleanArray(xs: Array[Boolean]): WrappedArray[Boolean]
implicit def wrapUnitArray(xs: Array[Unit]): WrappedArray[Unit]
```

这样做的原因是,Java原生类型的数组相比于统一数组更为高效

还有类似的方法,将数组转为 `scala.collection.mutable.ArrayOps` , `WrappedArray` 和 `ArrayOps` 的唯一区别是, `WrappedArray` 的转化函数(如 `filter` ),会返回一个新的 `WrappedArray` 而对应的 `WrappedOps` 中的转化函数返回 `Array`

类型的,`String` 也有相应的包装类型 `scala.collection.immutable.WrappedString` 和 `scala.collection.immutable.StringOps` 他们给 `String` 添加了集合方法,将其视为 `Char` 元素的集合

```scala
implicit def wrapString(s: String): WrappedString
implicit def unwrapString(ws: WrappedString): String

implicit def augmentString(x: String): StringOps
implicit def unaugmentString(x: StringOps): String
```

最后, Scala 2.10 中的一组隐式转换,可以防止  `null` 用来赋值,我们只举一个 `Byte` 的例子, `implicit def Byte2byteNullConflict(x: Null): Byte = sys.error("value error")` 在 `scala 2.11` 中去掉了转换函数,并给出了更简洁的错误信息

## 类型定义

```
Predef defines several types and type aliases.
To encourage the use of immutable collections, Predef defines aliases for the most popular, immutable collection types:
type Map[A, +B]       = collection.immutable.Map[A, B]
type Set[A]           = collection.immutable.Set[A]
type Function[-A, +B] = Function1[A, B]
Two convenient aliases for two- and three-element tuples have been deprecated in 2.11, on the grounds that they aren’t used enough and don’t add enough value to justify their existence:
type Pair[+A, +B]       = Tuple2[A, B]
type Triple[+A, +B, +C] = Tuple3[A, B, C]
Other Predef type members support type inference:
final class ArrowAssoc[A] extends AnyVal
Used to implement the a -> b literal syntax for creating two-element tuples. We discussed it in Implicit Conversions.
sealed abstract class <:<[-From, +To] extends (From) => To with Serializable
Witnesses that type From is a subtype of type To. We discussed it in Implicit Evidence.
sealed abstract class =:=[-From, +To] extends (From) => To with Serializable
Witnesses that types From and To are equal. We also mentioned it in Implicit Evidence.
type Manifest[T] = reflect.Manifest[T]
Used to retain type information that’s lost in the JVM’s type erasure. There is a similar type OptManifest. We’ll discuss them in Class Tags, Type Tags, and Manifests.
Other types, like scala.collection.immutable.List, are made visible through nested imports within Predef. Also, companion objects for some of the types are also made visible, such as =:=, Map, and Set.
```

## 条件检查方法

```scala
def assert(assertion: Boolean)
Test that assertion is true. If not, throw a java.lang.AssertionError.
def assert(assertion: Boolean, message: => Any)
Similar, but with an additional argument that’s converted to a string message.
def assume(assertion: Boolean)
Identical to assert, but conveys the meaning that the condition is assumed to be true when entering a block of code, such as a method.
def assume(assertion: Boolean, message: => Any)
Similar, but with an additional argument that’s converted to a string message.
def require(requirement: Boolean)
Identical to assume, but the Scaladoc says it conveys the meaning that the caller failed to satisfy some requirement; it could also convey the meaning that an implementation could not achieve a required result.
def require(requirement: Boolean, message: => Any)
Similar, but with an additional argument that’s converted to a string message.
```

尽管没有明确的表明,这些断言方法被加上了 `@elidable(ASSERTION)` 标记, 告诉编译器,除非相应标记(这里的标记是ASSERTION) 的参数大于编译时确定的阈值,否则对代码中的定义不产生字节码,如 `scalac -Xelide-below 2000` 将阻止所有标记参数值低于2000的定义生成字节码

## 输入输出方法

`Predef` 为我们定义了四种将字符串打印到 `stdout` 的形式
```scala
def print(x: Any): Unit
Convert x to a String and write it to stdout, without adding a line feed at the end automatically.
def printf(format: String, xs: Any*): Unit
Format a printf-style string using format as the format and the rest of the arguments xs, then write the resulting String to stdout, without adding a line feed at the end automatically.
def println(x: Any): Unit
Like print, but appends a line feed at the end automatically.
def println(): Unit
Writes a blank line to stdout.
```

Scala中的 `Predef` 中的 `stdin` 读取方法在2.11版本中移除在 `scala.io.ReadStdin` 对象中:

```Scala
def readBoolean(): Boolean
Reads a Boolean value from an entire line from stdin.
def readByte(): Byte
Reads a Byte value from an entire line from stdin.
def readChar(): Char
Reads a Char value from an entire line from stdin.
def readDouble(): Double
Reads a Double value from an entire line from stdin.
def readFloat(): Float
Reads a Float value from an entire line from stdin.
def readInt(): Int
Reads an Int value from an entire line from stdin.
def readLine(text: String, args: Any*): String
Prints formatted text to stdout and reads a full line from stdin.
def readLine(): String
Reads a full line from stdin.
def readLong(): Long
Reads a Long value from an entire line from stdin.
def readShort(): Short
Reads a Short value from an entire line from stdin.
def readf(format: String): List[Any]
Reads in structured input from stdin as specified by the format specifier.
def readf1(format: String): Any
Reads in structured input from stdin as specified by the format specifier, returning only the first value extracted, according to the format specification.
def readf2(format: String): (Any, Any)
Reads in structured input from stdin as specified by the format specifier, returning only the first two values extracted, according to the format specification.
def readf3(format: String): (Any, Any, Any)
Reads in structured input from stdin as specified by the format specifier, returning only the first three values extracted, according to the format specification.
```

## 杂项方法

```scala
def ???: Nothing
Called in a method body for a method that is actually unimplemented. It provides a concrete definition for the method, allowing enclosing types to compile as concrete (as opposed to abstract). However, if called, the method throws a scala.NotImplementedError. We first discussed it in Nested Types.
def identity[A](x: A): A
Simply returns the argument x. It is useful for passing to combinator methods when no change is required. For example, a work flow calls map to transform the elements of a collection, passing it a configurable function to do the transformation. Sometimes, no transformation is required, so you’ll pass identity instead.
def implicitly[T](implicit e: T): T
Used when an implicit argument list is specified with the type shorthand [T : M], in which case the compiler adds an implicit argument list of the form (implicit arg: M[T]). (The actual name isn’t arg, but something unique synthesized by the compiler.) Calling implicitly returns the argument arg. Discussed previously in Using implicitly.
```

# 对象的相等

## equals 方法

用于测试值相等,等于 Java 的 `equals` 方法,等于 Scala 的 `==`,但是当 `==` 在左边时例外
```scala
scala> null equals null
java.lang.NullPointerException
  ... 29 elided

scala> null == null
<console>:12: warning: comparing values of types Null and Null using `==` will always yield true
       null == null
            ^
res10: Boolean = true
```

## eq 和 ne 方法

`eq` 方法用于测试引用相等性(是否指向同一内存位置,`null eq null` 也得到 `==` 相同的警告)

## 数组相等和 sameElements 方法

`Array` 是原始的Java数组,与Scala库我们习惯的集合类型有着不同的方法
```scala
Array(1,2) == Array(1,2) //false
Array(1,2) sameElements Array(1,2) //使用 sameElements 方法比较
```
如果你试图比较数组,你可以考虑使用序列

```scala
List(1, 2) == List(1, 2)                // = true
List(1, 2) sameElements List(1, 2)      // = true
```

# 覆写类成员和 trait 成员

对Scala某一具体类型成员覆写必须使用 `override` ,定义抽象成员则可以忽略

#### 避免覆写具体成员

<设计模式> 书中描述的 **模板方法模式(template method pattern)** 中,父类提供某一方法的具体实现,并以此定义了某一行为的主要轮廓,需要使用多态行为时,该方法也会调用一些 `protected` 抽象方法,在此之后,子类型只需要实现 `protected` 抽象方法即可

```scala
case class Address(city: String, state: String, zip: String)
case class Employee(name: String, salary: Double, address: Address)

abstract class Payroll {
  def netPay(employee: Employee): Double = {                         //
    val fedTaxes   = calcFedTaxes(employee.salary)
    val stateTaxes = calcStateTaxes(employee.salary, employee.address)
    employee.salary - fedTaxes -stateTaxes
  }

  def calcFedTaxes(salary: Double): Double                           //
  def calcStateTaxes(salary: Double, address: Address): Double       //
}

object Payroll2014 extends Payroll {
  val stateRate = Map(
    "XX" -> 0.05,
    "YY" -> 0.03,
    "ZZ" -> 0.0)

  def calcFedTaxes(salary: Double): Double = salary * 0.25           //
  def calcStateTaxes(salary: Double, address: Address): Double = {
    // Assume the address.state is valid; it's found in the map!
    salary * stateRate(address.state)
  }
}

val tom  = Employee("Tom Jones", 100000.0, Address("MyTown", "XX", "12345"))
val jane = Employee("Jane Doe",  110000.0, Address("BigCity", "YY", "67890"))

Payroll2014.netPay(tom)    // Result: 70000.0
Payroll2014.netPay(jane)   // Result: 79200.0

The netPay method uses the Template Method Pattern. It defines the protocol for calculating payroll, and delegates to abstract methods for details that change year over year, etc.

The method for calculating federal taxes.

The method for calculating state taxes.

```
对于不要覆写父类具体方法可能有两个例外,一是
